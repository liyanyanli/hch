package api

import (
	"bufio"
	"net/http"
	"strings"

	"github.com/vmware/harbor/dao"
	"github.com/vmware/harbor/utils/log"
)

type Summary struct {
	Sum          int64 `json:"sum"`
	LevelSummary Level `json:"level_summary"`
	//NoVulnerabilites int64 `json:"noVulnerabilites"`
}
type Level struct {
	CriticalLevel   int64 `json:"critical_level"`
	HighLevel       int64 `json:"high_level"`
	MediumLevel     int64 `json:"medium_level"`
	LowLevel        int64 `json:"low_level"`
	NegligibleLevel int64 `json:"negligible_level"`
	NnknownLevel    int64 `json:"unknown_level"`
}

type PackagesVul struct {
	PackageName             string `json:"package_name"`
	PackageVersion          string `json:"package_version"`
	FixedVersion            string `json:"fixed_version"`
	VulnerabilitlesOriginal Level  `json:"vulnerabilitles"`
	VulnerabilitlesUpgrade  Level  `json:"pemaning_after_upgrade"`
}

//gai
//type PackageWeb struct {
//	Abnormal         string        `json:"abnormal"`
//	NotSupport       string        `json:"notsupport"`
//	Success          string        `json:"success"`
//	Packages_Summary Summary       `json:"packages_summary"`
//	Image_Packages   []PackagesVul `json:"image_packages"`
//}

type PackageWebAbnormal struct {
	Abnormal string `json:"abnormal"`
}

type PackageWebNotSupport struct {
	NotSupport string `json:"notsupport"`
}

type PackageWebSuccess struct {
	Success string `json:"success"`
}

type PackageWebInfo struct {
	Packages_Summary Summary       `json:"packages_summary"`
	Image_Packages   []PackagesVul `json:"image_packages"`
}

type Packages struct {
	CVE     string
	Package string
	Fixed   string
}

func cleanP() (p Packages) {
	return Packages{}
}

func Count(pa *Packages, pv *PackagesVul, pw *PackageWebInfo) {

	if strings.Contains(pa.CVE, "Low") {
		pv.VulnerabilitlesOriginal.LowLevel++
		if len(pa.Fixed) == 0 {
			pv.VulnerabilitlesUpgrade.LowLevel++
		}
		pw.Packages_Summary.LevelSummary.LowLevel++
	} else if strings.Contains(pa.CVE, "Negligible") {
		pv.VulnerabilitlesOriginal.NegligibleLevel++
		if len(pa.Fixed) == 0 {
			pv.VulnerabilitlesUpgrade.NegligibleLevel++
		}
		pw.Packages_Summary.LevelSummary.NegligibleLevel++
	} else if strings.Contains(pa.CVE, "Medium") {
		pv.VulnerabilitlesOriginal.MediumLevel++
		if len(pa.Fixed) == 0 {
			pv.VulnerabilitlesUpgrade.MediumLevel++
		}
		pw.Packages_Summary.LevelSummary.MediumLevel++
	} else if strings.Contains(pa.CVE, "High") {
		pv.VulnerabilitlesOriginal.HighLevel++
		if len(pa.Fixed) == 0 {
			pv.VulnerabilitlesUpgrade.HighLevel++
		}
		pw.Packages_Summary.LevelSummary.HighLevel++
	} else if strings.Contains(pa.CVE, "Unknown") {
		pv.VulnerabilitlesOriginal.NnknownLevel++
		if len(pa.Fixed) == 0 {
			pv.VulnerabilitlesUpgrade.NnknownLevel++
		}
		pw.Packages_Summary.LevelSummary.NnknownLevel++
	}  else if strings.Contains(pa.CVE, "Critical") {
		pv.VulnerabilitlesOriginal.CriticalLevel++
		if len(pa.Fixed) == 0 {
			pv.VulnerabilitlesUpgrade.CriticalLevel++
		}
		pw.Packages_Summary.LevelSummary.CriticalLevel++
	}
}
func (ra *RepositoryAPI) GetPackageSummary() {
	ra.ValidateUser()
	const PACKAGE = `Package:`
	const FIX = `Fixed version:`
	const SUCESS = `Success! There is no vulnerabilities has been detected in your image!`
	const NOTSUPPORT = `NOTE: No features have been detected in the image. This usually means that the image isn't supported by Clair!`
	var abnormal string
	repositoryname := ra.GetString("repo_name")

	log.Debugf("****************** %s:%s", repositoryname)
	if len(repositoryname) == 0 {
		ra.CustomAbort(http.StatusBadRequest, "repositoryname is nil")
	}
	clair_result, err := dao.GetClairResultByRepoName(repositoryname)
	if err != nil {
		log.Errorf("error happens when get repositoryname from sql: %v", err)
		abnormal = `Error happens when get info from databases!`
	}
	var image_packages []Packages
	p := Packages{}
	//pw := PackageWeb{}

	pwa := PackageWebAbnormal{}
	pwi := PackageWebInfo{}
	pws := PackageWebSuccess{}
	pwn := PackageWebNotSupport{}

	str := string(clair_result)
	/*
		the result is empty
	*/
	if len(str) == 0 {
		log.Info("the clair result is empty")
		abnormal = `The scan result for this image is empty!`
	}
	/*
		the iamge is safe
	*/
	//if strings.Contains(str, "Success") {
	if strings.Contains(str, "Success!")||strings.Contains(str, "No vulnerabilities") {
		log.Debugf("the result from clair is success")
		pws.Success = SUCESS
		ra.Data["json"] = pws
		ra.ServeJSON()
		return
	}
	/*
		clair not suppose current image
	*/
	if strings.Contains(str, "the image isn't supported by Clair") {
		log.Debugf("the image isn't supported by Clair")
		pwn.NotSupport = NOTSUPPORT
		ra.Data["json"] = pwn
		ra.ServeJSON()
		return
	}
	/*
		analysis the result of clair
	*/
	scanner := bufio.NewScanner(strings.NewReader(str))
	for scanner.Scan() {
		line := scanner.Text()
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "CVE-") || strings.HasPrefix(line, "RHSA-"){
			image_packages = append(image_packages, p)
			p = cleanP()
			p.CVE = line
		} else if strings.HasPrefix(line, "	"+PACKAGE) {
			line = strings.Replace(line, " ", "", -1)
			line = strings.Replace(line, "	", "", -1)
			line = strings.Replace(line, "\n", "", -1)
			p.Package = line[8:]
		} else if strings.HasPrefix(line, "	"+FIX) {
			line = strings.Replace(line, " ", "", -1)
			line = strings.Replace(line, "	", "", -1)
			line = strings.Replace(line, "\n", "", -1)
			p.Fixed = line[13:]
		}

	}
	image_packages = append(image_packages, p)

	for _, h := range image_packages {
		if len(h.CVE) == 0 {
			continue
		}
		var flag = 0
		for i := 0; i < len(pwi.Image_Packages); i++ {
			if strings.EqualFold(h.Package, pwi.Image_Packages[i].PackageName) {
				flag = 1
				Count(&h, &pwi.Image_Packages[i], &pwi)
			}
		}
		if flag == 0 {
			po := PackagesVul{}
			po.PackageName = h.Package
			po.FixedVersion = h.Fixed
			Count(&h, &po, &pwi)
			pwi.Image_Packages = append(pwi.Image_Packages, po)
		}

	}
	/*
		from"name@version" to  "name"+"version"
	*/
	for i := 0; i < len(pwi.Image_Packages); i++ {
		sl := strings.Split(pwi.Image_Packages[i].PackageName, "@")
		pwi.Image_Packages[i].PackageName = sl[0]
		pwi.Image_Packages[i].PackageVersion = sl[1]

	}
	pwi.Packages_Summary.Sum = int64(len(pwi.Image_Packages))
	/*
	   the result from clair is abnormal,the number of package is zero
	*/
	if pwi.Packages_Summary.Sum == 0 {
		log.Debugf("the result from clair is abnormal")
		pwa.Abnormal = abnormal
		ra.Data["json"] = pwa
		ra.ServeJSON()
		return
	}
	ra.Data["json"] = pwi
	ra.ServeJSON()
}
